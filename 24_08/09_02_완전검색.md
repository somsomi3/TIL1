## 완전검색
T= 40
for i in range(10, T):
    a = i%10 = 1 or 2 or 3

for i in range(1, 4):
    for j in range(1,4):
        print(i, j)

이런식으로 풀면.. for문이 계속 ...n 중 for문...

for 문하나로 하고, 자기자신인 재귀를 호출해온다.

재귀호출에서 어려운것: 디버깅, 설계.

재귀호출의 첫번째 특징은,
메인에 있는 x를, KFC라는 함수에 넣으면..

정수는 원본이 바뀌지 않는다. 

def KFS(x):
    print(x)    #4
    x += 1
    print(x)    #5
x = 3
KFC(x+1)
print(x)    #3

대입을 하지 않았기 때문에 값변경은 없다.

KFC(x+1)은 그냥 값을 더해서 파라미터로 던져주는 거다. 
(값만 복사가 되는것)

+ 상식
: 얕은 복사 깊은 복사
: python call by reference
:python call by value



** 함수가 종료가 되면, 그 함수를 호출했던 시점으로 다시돌아가서, 

거기서부터 코드가 다시 실행이 된다.
BTS(x+5): 코드가 여기서 부터 다시실행,
이때의  x는 KFS가 가진 x이므로, 
9이다. 

그래서 8-> 14 -> 9 -> 3 순서로 실행이 된다. 

scope개념이 달라서, 메인의 x와 KFC의 x가 다르다.

* 재귀를 연습하기 전, 알아야 할 함수의 특징2
- 함수가 끝나면, Main으로 되돌아 오는 것이 아니라, 해당 함수를 호출했던 곳으로 돌아온다.

- 실행결과는?:
 
 
------------------------------------


def func(x):
    x += 1
# 위아래의 엑스는 서로다는 메모리를 가지는 다른 객체이다.

x = 10
func(x)
print(x)

def func(x):
    x[0] += 1
# 위아래의 엑스는 서로다는 메모리를 가지는 다른 객체이다.

x = [10]
func(x)
print(x)


무한 재귀 호출
meme
def Main(x):
    KFC(0)
    print('끝')


def KFC(x):
    KFC(x+1)
    KFC(x)

무한 반복되는 에러 코드/
def KFC(x):
    KFC(x+1)

KFC(0)

파이썬 재귀: 깊이제한 1,000
함수 호출: 값만 복사해서 사용 : 메모리 사용

------------------------------------------


def KFC(x):
    KFC(x+1)

KFC(0)

#+제약조건 써주기
    if x ==2:
        return


시작점: 0에서 시작
종료조건: 5 혹은 6에서 종료

def func(x):
    #1. 기저조건(종료조건)
    if x ==6:
        return

    #여기는 뭐가 들어갈까? 종료조건을 만족하지 못한것들!
    # 2. 다음 재귀 호출 전
    print(x, end=' ') #5
    # 3. 재귀 호출: 현재 값과 얼마나 다를까? 를 적는것! = 현재 값에 무슨 수식을 적용해서 넘겨줄까? 를 적는 것.
    func(x+1) # 다음 재귀 호출에서는 현재보다 x값이 1이 커야한다.
                # 6
    # 4. 호출하고 돌아왓을때
    # 위에 5, 6이기 땨ㅐ문에, x는 5이므로 여기서는 그대로 출력을 해주면 된다.
    print(x, end=' ')

start = 0
func(start)


재귀호출 코드가 2개. : 트리, 등에서 했었다.

path = []

def KFC(x):
    # 종료조건
    if x ==4:
        print(path)
        return

    # 종료되지 않는다면
    for i in range(1, 7):# 0부터 시작 햇으니... 5인가??
        path.append(i)
        KFC(x + 1)
        path.pop()

KFC(1)

path = [] # 경로를 기록할 리스트

def KFC(x): # 재귀함수를 설계
    # 종료조건
    if x ==6:
        print(path)
        return

    # 종료되지 않는다면
    for i in range(1, 5):# 0부터 시작 햇으니... 5인가??
        path.append(i)
        KFC(x + 1)
        path.pop()

KFC(1)


--------------------------------------

path = [] # 경로를 기록할 리스트
used = [0]*7 # 1~6 숫자의 사용 여부를 기록할 리스트. 쓰면1, 안쓰면0을 저장함.

def recur(level): # 재귀함수를 설계
    if level == 3:
        #1. 기저조건
        print(*path)
        return

    # 2. 후보군을 반복하면서
    for i in range(1, 7):
        # i가 이미 뽑혔다면, continue해라.!! 이하 두줄이 중복제거된 순열
        #아래 코드의 단점: in 이 들어간다.-> 시간 복잡도로 O(len(path). 매우오래걸린다.
        # 가지가 많은 경우에는 사용하면 안됨. 시간 초과 위험도가 높다.
        # if i in path:
        #     continue

        ## 방문하지 않았다면 실행해라
        ## == 방문했다면 실행하지 마라.
        #i가 이미 뽑혔다면, continue해라.-> 컨디뉴가 가독성이 좋아서 사용함.
        if used[i] ==1:
            continue

    # 2.1 재귀호출 전 = 경로기록: append는 경로기록인데, 그전에 사용기록을 해준다. used로.
        used[i] = 1 # False로 해놓고 True로 바꿔도 된다. 어차피 똑같으니까.#사용을 했습니다.
        path.append(i)                                              #경로에 추가하겠습니다.
    # 2.2 다음 재귀호출(파라미터 전달)
        recur(level+1)
    # 2.3 돌아왔을때- 사용했던 경로 삭제 + 사용 여부 초기화
        path.pop()
        used[i] = 0

recur(0)    # 호출: 시작점을 같이 전달해주는 경우가 많다.


# 중복을 취급하지 않는 '순열'구현 방법
    # 1. 중복순열 코드를 작성한다.
    # 2. 중복을 제거하는 코드를 추가하면  순열 코드가 된다.

# 중복을 제거하는 원리
    #전역리스트를 사용하면, 이미 선택했던 숫자인지 아닌지 구분할 수 있다.
    #이를 used배열, 또는 visited배열 이라고 한다.( DFS, BFS에 사용되는 것과 같다. )


    #완전탐색.: 모두 시도해보는 것이 핵심. 알고리즘을 봣을때, 가장먼저 실행하곤 함.
    # 완전 탐색 문제1. 주사위 눈금의 합
    # : 3개의 주사위를 던져 나올 수 있는 중복순열에 대해, 합이 10이하가 나오는 경우는 총몇가지?
    # 서로 영향이 없는 독립적인 문제. 다른 숫자와 영향주지x, 규칙x, 미리계산x -> 모든 케이스를 다해야함.

path = []

def recur(level, total):
    # 가지치기: 이미 10을 넘는 경우의 수는 계산할 필요 없다.
    if total >10:

    # 기저조건: 3개를 던졌을때 종료하기
    if level == 3:
        if total <= 10:
            print(path)


        return

    #후보군 돌기
    for i in range(1, 7):
        #i: 뽑힌 주사위 숫자
        path.append(i)
        recur(level+1, total+i) #주사위 결과를 더하여 전달
        path.pop()

recur()

---------------------------------------

 [2]
 순열 
 : 가장 마지막 레벨에 도착했을때, 이동경로를 출력한다. 


[3]설명
 : 완전탐색을 할때는, 가지치기를 먼저 생각하지 말라!!