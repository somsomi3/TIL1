# APS(Algorithm Problem Solving)

## 큐

### 큐(Queue) 의 특성

- 스택과 마찬가지로 삽입과 삭제의 위치가 제한적인 자료구조
- : 큐의 뒤에서는 삽입만 하고, 큐의 앞에서는 삭제만 이루어지는 구조

\*\* 선입 선출 구조(FIFO: First In First Out)

- 큐에 삽입한 순서대로 원소가 저장되어, 가장 먼저 삽입(First In)된 원소는 가장먼저 삭제 (First Out)된다.

-큐의 선입 선출 구조
머리(Front): 저장된 원소 중 첫번째 원소(또는 삭제된 위치)
꼬리(Rear): 저장된 원소 중 마지막 원소

-큐의 기본 연산
: 삽입(enQueue)
: 삭제(deQueue)

-큐의 사용을 위해 필요한 주요 연산은 다음과 같음
연산: 기능
enQueue(item) 큐 뒤쪽(rear 다음)에 원소를 삽입하는 연산
deQueue() 큐의 앞쪽(front)에서 원소를 삭제하고 반환하는 연산
createQueue() 공백상태의 큐를 생성하는 연산
isEmpty() 큐가 공백상태인지를 확인하는 연산
isFull() 큐가 포화상태인지를 확인하는 연산
Qpeek() 큐의 앞쪽에서 원소를 삭제 없이 반환하는 연산

-큐의 연산과정

1. enQueue

   1. 공백 큐 생성: createQueue();
      (front와 rear가 같다는 것이 중요!!!)
      : rear 를 하나 증가시키고, 큐를 넣음.

   2. 원소 A삽입: enQueue(A);

   3.

   4. 원소 반환/삭제: deQueue();
      :

   5.

### 선형큐( 앞에서 설명 한 큐는 선형 큐이다. )

: 1차원 배열을 이용한 큐

- 큐의 크기= 배열의 크기
- front : 저장된 첫번째 원소의 인덱스
- rear: 저장된 마지막 원소의 인덱스

: 상태 표현

- 초기 상태:front = rear = -1
- 공백 상태:front == rear
- 포화 상태:rear -- n-1(n:배열의 크기, n-1: 배열의 마지막 인덱스)

### 초기공백 큐 생성

```
N = 10
q = [0]*N
front = -1
rear = -1

rear += 1 #enqueue(1)
q[rear] = 1
rear +=1
q[rear] = 2 #enqueue(2)
rear += 1 #enqueue(3)
q[rear] = 3

front += 1 #dequeue()
print(q[front])
front += 1 #dequeue()
print(q[front])
front += 1 #dequeue()
print(q[front])
```

### 삽입: enQueue(item)

- 마지막 원소 뒤에 새로운 원소를 삽입하기 위해
  1. rear값을 하나 증가시켜 새로운 원소를 삽입할 자리를 마련
  2. 그 인덱스에 해당하는 배열 원소 Q[rear]에 item을 저장

### 삭제 : deQueue()

- 가장 앞에 있는 원소를 삭제하기 위해
  1. front값을 하나 증가시켜 큐에 남아있는 첫번째 원소 이동
  2. 새로운 첫번째 원소를 리텅함으로써 삭제와 동일한 기능

### 공백상태 및 포화상태 검사 : isEmpty(), isFull()

- 공백 상태: front == rear
- 포화 상태: rear == n-1(n:배열의 크기, n-1: 배열의 마지막 인덱스)

### 검색: Qpeek()

- 가장 앞에 있는 원소를 검색하여 반환하는 연산
- 현재 front의 한자리 뒤(front+1)에 있는 원소, 즉 큐의 첫번째에 있는 원소를 반환

#### 연습문제

- 큐를 구현하여 다음 동작을 확인해 봅시다.
  : 세개의 데이터 1, 2, 3을 차례로 큐에 삽입하고
  : 큐에서 세 개의 데이터를 차례로 꺼내서 출력한다.
  1, 2, 3이 출력되어야 함.

### 원형큐

- 선형큐 이용시의 문제점
  : 잘못된 포화 상태 인식
  : 선형 큐를 이용하여 원소의 삽입과 삭제를 계속할 경우,
  배열의 앞부분에 활용할 수 있는 공간이 있음에도 불구하고,
  rear=n-1인 상태, 즉 포화상태로 인식하여 더 이상의 삽입을 수행하지 않게 됨.

  : 해결방법1
  : 매 연산이 이루어질때마다 저장된 원소들을 배열의 앞부분으로 모두 이동시킴
  : 원소 이동에 많은 시간이 소요되어 큐의 효율성이 급격히 떨어짐.

  : 해결 방법 2
  :원형 큐 이용

- 원형큐의 구조
  : 초기 공백상태
  front = rear = 0
  : Index의 순환
  : front와 rear의 위치가 배열의 마지막 인덱스인 n-1을 가리킨후,
  그 다음에는 논리적 순환을 이루어 배열의 처음 인덱스인 0 으로 이동해야함.
  : 이를 위해 나머지 연산자 mod를 사용함

- 원형 큐의 연산 과정
  : enQueue
  : deQueue

---

```
Q_SIZE = 4
cQ = [0]*Q_SIZE
front = rear = 0

rear =(rear+1)%Q_SIZE   #enq(1)
cQ[rear] = 1

rear =(rear+1)%Q_SIZE   #enq(2)
cQ[rear] = 2

rear =(rear+1)%Q_SIZE   #enq(3)
cQ[rear] = 3

front =(front+1)%Q_SIZE
print(cQ[front])


front =(front+1)%Q_SIZE
print(cQ[front])

front =(front+1)%Q_SIZE
print(cQ[front])

rear =(rear+1)%Q_SIZE   #enq(10)
cQ[rear] = 10

rear =(rear+1)%Q_SIZE   #enq(20)
cQ[rear] = 20

```

### 연결 큐

#### 연결 큐의 구조

- 단순 연결 리스트(Linked List)를 이용한 큐
  : 큐의 원소: 단순 연결 리스트의 노드
  : 큐의 원소 순서: 노드의 연결 순서, 링크로 연결되어 있음.
  : front: 첫번째 노드를 가르키는 링크
  : rear: 마지막 노드를 가리키는 링크

  - 상태 표현
    : 초기 상태: front = rear = null
    : 공백 상태: front = rear = null

## 데크(덱)deque

- 컨테이너 자료형 중 하나
- 데크 객체: 양쪽 끝에서 빠르게 추가와 삭제를 할 수 있는 리스트류 컨테이머
- 연산
  : append(x): 오른쪽에 x추가
  : popleft(): 왼쪽에서 요소를 제거하고 반환. 요소가 없으면 IndexError

```
  from collections import deque

deque_q = deque()
for i in range(10000000):
    deque_q.append(i)
for _ in range(1000):
    deque_q.popleft()
print('end')    #백만개를 다찍고 나면, end를 출력한다.

# list_q = []
# for i in range(10000000):
#     list_q.append(i)
# for _ in range(1000):
#     list_q.pop(0)
# print('end')    #백만개를 다찍고 나면, end를 출력한다.
#
# q = deque()
```

## 우선 순위 큐

특성: 우선 순위를 가진 항목들을 저장하는 큐. FIFO순서가 아니라 우선순위가 높은 순서대로 먼저나가게된다.

적용분야: 시뮬레이션 시스템, 네트워크 트래픽제어, 운영체제의 테스크 스케줄링

- 배열을 이용한 우선순위 큐
  : 배열을 이용하여 자료저장
  : 원소를 삽입하는 과정에서 우선순위를 비교하여 적적한 위치에 삽입
  : 가장 앞에 최고 우선순위의 원소가 위치하게 됨

  :문제점
  :배열을 사용하므로, 삽입니아 삭제 연산이 일어날때 원소의 재배치가 발생함
  : 이에 소요되는 시간이나 메모리가 큼

- 리스트를 이용한 우선순위 큐

## 버퍼

: 데이터를 한 곳에서 다른 한 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리의 영역
: 버퍼링: 버러를 활용하는 방식 또는 버퍼를 채우는 동작을 의미한다.

버퍼의 자료 구조
: 버퍼는 일반적으로 입출력 및 네트워크와 관련된 기능에서 이용된다.
: 순서댇로 입력/출력/전달되어야 하므로, FIFO방식의 자료구조인 큐가 활용된다.

## 설명

- 큐는 자료구조이다. 알고리즘과는 구분되는.
- 큐는 선입선출.
- 꼬리에 삽입하므로, 그부분을 알기 위해 rear를 만듬
- 머리에서 뽑아내므로, 그 부분을 알기 위해 front를 만듬
-

- 단순 연결리스트 쓰는이유?
  : 물리적인 주소 순서를 맞춰야 한다.
  : 연결 리스트의 시간복잡도는? O(N)이다. 넣는과정은 O(1)이지만.
