# APS(Algorithm Problem Solving)

## 스택2

### 계산기1

-step1.중위표기식의 후위표기식 변환 방법1

:수식의 각 연산자에 대해서 우선순위에 따라 괄호를 사용하여 다시 표현한다.

: 각 연산자를 그에 대응하는 오른쪽괄호 뒤로 이동시킨다.

: 괄호를 제거한다.

-step1. 중위 표기법에서 후위 표기법으로의 변환 알고리즘(스택 이용)2

: 입력받는 중위 표기식에서 토큰을 읽는다

: 토큰이 피연산자이면 토큰을 출력한다,

: 토큰이 연산자(괄호포함)일 때, 이 토큰이 스택의 top 의 연산자의 우선순위가 토큰의 우선순위보다 작을때까지 스택에서 pop한 후 토큰의 연산자를 push한다.

만약 top에 연산자가 없으면 push한다.

: 토큰이 오른쪽 괄호이면 스택 top에 왼족 괄호가 '('가 올때까지 스택에 pop연산을 수행하고 pop한 연산자를 출력한다. 왼쪽 괄호를 만나면 pop만 하고 출력하지는 않는다.

: 중위 표기식에 더 읽을 것이 없다면 중지하고, 더 읽을 것이 있다면 1부터 다시 반복한다.

: 스택에 남아 있는 연산자를 모두 pop하여 출력한다

- 스택 밖의 왼쪽 괄호는 우선 순위가 가장 높으며, 스택 안의 왼쪽 괄호는 우선순위가 가장 낮다.

\*연습 문제

#### 계산기1

(6+5\*(2-8)/2)

;여는 괄호는 무조건 우선순위 가장먼저로 넣어준다.

;닫는 괄호가 나올때는, 여는 괄호가 나올때 까지, 스택안에 있는 모든것을 팝한다. (숫자는 밑에 넣어주고, 여는 괄호는 스택에서 꺼내서 버려라.)

```
2+(3*4)/5
234*5/+


2+(3*4)+5
234*+5+

2+3*4+5 # 괄호가 없으면, 우선순위가 더 낮은 애를 만날때까지 다 꺼내라.
234*+5+
```

### 계산기2

### 백트래킹

-백트래킹(Backtracking)기법은 해를 찾는 도중에 막히면(즉, 해가 아니면)되돌아 가서 다시 해를 찾는 기법이다.

-백트래킹 기법은 최적화 문제와 결정문제를 해결할 수 있다.

-결정문제: 문제의 조건을 만족하는 해가 존재하는지의 여불르 'yes'또는 'no'가 답하는 문제

;; 미로찾기, n-Queen문제, Map coloring, 부분집합의 합(Subset Sum)문제 등

-백트래킹과 깊이우선탐색과의 차이

: 어떤 노드에서 출발하는 경로가 해결책으로 이어질 것 같지 않으면 더 이상 그 경로를 따라가지 않음으로써 시도의 횟수를 줄임( Prunning 가지치기 )

: 깊이 우선탐색이 모든 경로를 추적하는데 비해, 백트래킹은 불필요한 경로를 조기에 차단.

: 깊이우선탐색을 가하기에는 경우의 수가 너무나 많음. 즉 N!가지의 경우의 수를 가진 문제에 대해 깊이 우선탐색을 가하면 당연히 처리 불가능한 문제.

: 백트래킹 알고리즘을 적용하면 일반적으로 경우의 수가 줄어들지만, 이 역시 최악의 경우에는 여전히 지수함수 시간(Exponential Time)을 요하므로 처리 불가능.

### 백트래킹이란?

- 모든 후보를 검사? No!!
- 백트래킹 기법
- : 어던 노드의 유망성을 점검한 후 유망 하지 않다고 결정되면,
  그 노트의 부로로 되돌아가 다음 자식 노드로 감.

- 어떤 노드를 방문하였을 때, 그 노드를 포함한 경로가 해답이 될 수 없으면,
  그노드는 유망하지 않다고 하며, 반대로 해답의 가능성이 있으면 유망하다고 한다.

- 가지치기: 유망하지 않은 노드가 포함되는 경로는 더 이상 고려하지 않는다.

- 백트래킹을 이용한 알고리즘 절차:

1. 상태공간 트리의 깊이 우선 검색을 실시 한다.
2. 각 노드가 유망한지를 점검한다.
3. 만일 그 노드가 유망하지 않으면, 그 노드의 부모노드로 돌아가서 검색을 계속한다.

- 미로 찾기

  - 스택을 이용하여 지나온 경로를 역으로 되돌아 간다.
  - 스택을 이용하여 다시 경로를 찾는다.
  - ==> 역순으로 이용해야 하는 것은, 대부분 스택을 사용한다.

- n-Queen문제

* 상태 공간 트리

-깊이 우선 검색 vs 백트래킹: 백트래킹은 항상 효과가 있는 것은 아니다.

- Map coloring
- 부분집합의 합(Subset Sum)문제

## 부연 설명

'''
import sys
sys.stdin = open('input.txt')

for \_ in range(10): # 10개의 테스트 케이스
tc, N = map(int, input().split())
edges = list(map(int, input().split()))
SIZE, START, END = 100, 0, 99
result = 0

    def dfs(vertex, visited):
        global result

        # 이미 도착지를 찾은 경우에는 아래 로직을 실행하지 않도록 함 ( 이런게 백트래킹 )
        if result == 1:
            return

        # 시작지점이 도착지에 도착한 경우에는 결과를 1로 바꾸고 종료
        if vertex == END:
            result = 1
            return

        # 현재 노드를 방문 처리
        visited[vertex] = True

        # 인접한 노드에 대해서 DFS 실행, 대신 방문한 노드는 DFS를 실행하지 않음
        for adj_vertex in graph[vertex]:
            if visited[adj_vertex]:
                continue
            dfs(adj_vertex, visited)
    ```
    DFS 파라미터로 무러 해야하는가 감이 안올때? 위에 있는 변수를 다 집어넣어라
    1. 재귀 호출을 중단하기 위한 파라미터
    -> 시작 지점이 목표지점에 도달했을 때
    -> 목표 지점은 고정되어있고,
    -> 시작 지점을 파라미터로 건넨다.

    2. 누적해서 가져간다던가, 목표하는게 있을텐데, 계속 가져가고 싶은 값
    -> 방문여부를 확인하는 변수, 시작지점
    ```


    # 그래프 초기화
    # 인접리스트로 구현
    # 100개의 정점이 있기 때문에 100개의 2차원 배열을 할당함
    # 여기서 이전 코드의 V+1을 하지 않는 이유는 정점값이 0부터 주어지기 때문
    graph = [[] for _ in range(SIZE)]

    for i in range(0, len(edges), 2):
        graph[edges[i]].append(edges[i + 1])

    # DFS 수행
    visited = [False] * SIZE
    dfs(START, visited)

    print(f'#{tc} {result}')

'''
