## 트리 2
- 이진 탐색 트리
- 힙

[[1]]
### 이진 탐색 트리(Binary Search Tree)
:이진 트리를 활용한 자료구조
: 탐색을 잘한다? 추가, 삭제 등이 효율적인 것.

:BST자료구조
-Data들을 빠르게 검색 할 수 있도록 체계적으로 저장해두고, 최대 O(log n)의 빠른 속도로 값ㅇ르 검색 할 수 있는 자료구조.(밑이 2이다. )


-빠르게 검색 될 수 있도록, 특정 규칙을 갖는 이진트리

.. 특정규칙이 뭘까??

-리스트 vs BST
: 리스트의 성능
삽입: O(n), 단 맨 끝에 삽입은 O(1)
((리스트 중앙에 밀어넣어야 하므로, O(n)))
삭제
탐색: O(n)
::in을 썻으므로, 시간초과의 위험이 있다.

근데, 
: BST성능
삽입: 평균 O(logN)
삭제: 평균 O(logN)
탐색: 평균 O(logN)

: 파이썬 공식 라이브러리에는  Binary Search Tree
자료구조가 없어서, 직접 구현해서 사용해야 한다. (자바는 있다.)

주어진 숫자들:
3 5 1 2 7 4 -5

규칙: 부모 노드 보다 크면 오른쪽, 작으면 왼쪽에 삽입해보자.

3: 아무것도 없으니 그냥 넣

3, 5: 5가 3보다 크므로, 3의 오른쪽에 넣어줌.

1 3 5 : 1이 3보다 작으므로, 3의 왼쪽에 넣어줌.

1 2 3 5:2는 1보다 크므로 1의 오른쪽

1 2 3 5 7:

1 2 3 4 5 7

-5 1 2 3 4 5 7

: 삽입하는 과정이 매우 간단함.
: 내자리가 어디인지 찾아가는 것.
:시간 복잡도 O(log N)
: 왜 로그엔일까??????????????
: 제일 좋은 경우, 트리의 높이만큼만 나오면 되므로, logN이다. 

: 정렬된 형태로 주어지만, 
1 2 3 4 5 6 7: 이렇게 1자로 쭉들어가는 최악의 경우.

: BST는 반드시 완전이진 트리가 아니다.
그냥이진 트리이다.
최악의 순간인 1 2 3 4 5 6 7 가 들어온 경우.

높이(h)= N
: 리스트랑 BST가 차이가 없는 경우. ㅠㅠ

: 잘없는 경우이긴 하다. 

: 탐색
삽입, 삭제. 

:BST에서 DFS중위순회를 하게 되면 Key값이 작은 순서대로 탐색이 가능하다.

: 이진 탐색 트리의 성능
: 탐색, 삽입, 삭제 시간은 트리의 높이만큼 시간이 걸린다.
(logN~ 편향시 N(=리스트와 거의 동일하다))
- 평균의 경우
- 최악의 경우

: 삭제 
: BST규칙(부모보다 작으면 왼쪽, 크면 오른쪽)을 유지하면서 되야함. 
: 13, 12, 9를 차례로 삭제해보자.

[1] 13: leaf노드는 그냥삭제해도 문제 없다.

[2] 12: 날리고 9와 15를 연결.
    : 자식이 하나일때도, 자식을 부모로 연결하고-> 삭제.
    : 위, 아래 이미 규칙이 완벽해서 연결후 삭제해도 아무문제 없음.

[3] 9: 자식이 두개일때는 어떻게 해야할까?
    : 아마도.. 4vs 12해서 큰 숫자가 오면.. 아무 문제 없지 않을까?
    : 자식이 둘이라면, 왼쪽 서브트리의 가장 큰값이나,
    오른쪽 서브트리의 가장 작은값
    둘 중 아무 거나 오면된다. 
    왜냐면, 왼쪽에 작은거 몰아놓고
    오른쪽에 큰값을 몰아놧으니까..
    중간값을 채워주는 것!!

[4] 4: 4를지운다면?? 
    : 굳이 루트노드일 필요없이, 자식이 두개인데, 
    : 삭제하고자 하는 노드의 왼쪽 서브트리, 오른쪽 서브트리를 보면된다. 3또는 6(그림에 6옆에 8이 추가되어있음.)

[5] 10은 리프노드.. 끝까지 찾아 들어가야 나온다?
리프노드가 아닐수도 있다!!!!!!!!!!!
10을 복사해서 루트로 올리고, 값을 삭제해 주면됨.

: 반례는 없음.


*** 이진 트리의 삭제연산은 자식의 개수에 따라 다르게 동작.
-0개
-1개
-2개

삭제같은 경우는 왜 logN(밑은 2)일까?
13 그냥지우면 되는대;...

이유는, 1. 탐색을 하고 2. 지워야 하므로.

12를 지우는 경우는 2번.
6지우는 것, 이동 2번..
->> 탐색때문에 logN이다.

[[2]]
### 힙(Heap)

:BST보다 중요함.
: 완전 이진 트리에 있는 노드 중에서 키 값이 가장 큰 노드나 키값이 가장 작은 노드를 찾기 위해서 만든 자료구조

: 최대 힙(max heap)
- 키 값이 가장 큰 노드를 찾기위한 완전이진트리
- 부모노드의 키 값 > 자식노드의 키값
- 루트 노드: 키 값이 가장 큰 노드

-> 최대힙을 연산을 반대로 하면, 최소 힙.

: 최소 힙(min heap)
- 키 값이 가장 작은 노드를 찾기 위한 완전이진트리
- 부모노드의 키 값< 자식 노드의 키값
- 루트 노드: 키 값이 가장 작은 노드

-힙이 아닌 이진트리의예
: 완전이진 트리가 아니다.
: 부모가 작거나 큰게 섞여 있음.

-17 삽입.
: 중간에 넣으면 다 깨지므로, 일단 맨뒤에 넣는다.
: 부모자식 비교해가면서, 내위치를 찾아가는 것.->비교랑 swap연산이 적용됨. 
형제끼리는 아무 상관없고, 부모랑 나랑만 보면됨.

-최대힙, 최소힙은,
: 힙은 제일 위에 것만 보면된다.
탐색, 삭제는 모두 루트 노드원소만 가능.

-힙에서의 삭제예
1.2. 마지막노드와 자리를 바꾸고 삭제하자.
3. (삽입노드 10 < 자식노트 19) : 자리 바꾸기
자식노드중 더 큰값이랑 자리를 바꾼다. 
: 10은 15, 19중에서 반드시 19랑 바꿔야함. 
15랑 바꾸면 15 랑 19가 규칙이 빠꺼서 다시 비교해야함.
4. 자리확정


-힙자료 구조를 만들어 놓으면, 우선순윅 높은 데이터 부터 확인이 가능.
-힙 자료구조는 우선순위 큐를 구현 할 수 있다!!!!!!*****
메우중요!!!!!!!!!!!!!!!!!!!!!!!!!!
- 내장 함수 있음!!!!!!!!!!!!!!!!
그냥 쓰면 안됨.시간 계산때문에..

-삽입에 걸리는 시간은? 
1. 맨뒤에 넣는 것은 그냥 넣기
2. 내부모랑만 비교하면됨.
3. 시간은 정확하게 logN은 아니지만,
logN이다 생각해라. 
// N개의 데이터를 힙으로 만든다: 시간복잡도가 얼마나 걸릴까?
-> N*logN 이다. (전체적으로 계산 할때.)

(한번은 logN)

-삭제에 걸리는 시간은?
: 바꾸고 자리 차지하는 것이므로.
O(logN)+알파 정도


[[3]]
이진 탐색 트리, 항상 왼쪽에 값을 넣어야 하는가?


