# APS

## 스택1

### Memoization

: 메모이제이션은 컴퓨터 프로그램

```
 def fibo1(n):
     #global memo
     if n >= 2 and memo[n] ==0:
         memo[n] = fibo1(n-1) + fibo1(n-2)
     return memo[n]

 n = 7
 memo =[0]*(n+1)
 memo[0] =0
 memo[1] =1
 fibo1(n)
 print(memo)

#------------------------------------------
# 재귀함수를 사용한 구현법
def fibo1(n):
    #global memo
    if n >= 2 and memo[n] == 0:
        memo[n] = fibo1(n-1) + fibo1(n-2)
    return memo[n]

def fibo(n):
    if n<2:
        return n
    else:
        return fibo(n-1) + fibo(n-2)

n = 100
memo =[0]*(n+1)
memo[0] =0
memo[1] =1
# print(fibo1(n))
print(fibo(n))
```

-재귀함수 구현은 시간이 매우 오래걸려서, 플삼을 누르더라도 답이 즉각나오지 않는다.

### DP: 동적 계획법

: 작은 부분부터 시작하여

### DFS: 깊이 우선 탐색

-비선형 구조인 그래프 구조는 그래프로 표현된 모든 자료를 빠짐없이 검색하는 것이 중요함. -두가지 방법
: 깊이 우선 탐색(Depth First Search, DFS)
: 너비 우선 탐색(Breadth First Search, BFS)

#### 깊이 우선 탐색(Depth First Search, DFS)

: 시작 정점의 한 방향으로 갈 수 잇는 경로가 있는 곳까지 깊이 탐색해 가다가 더 이상 갈 곳이 없게 되면, 가장 마지막에 만났던 갈림길 간선이 있는 정점으로 되돌아와서 다른 방향의 정점으로 탐색을 계속 반복하여 결국 모든 정점을 방문하는 순회방법

-가장 마지막에 만났던 갈림길의 정점으로 되돌아가서 다시 깊이 우선 탐색을 반복해야 하므로 후입선출 구조의 스택 사용
: 이때 필요한 것은, 내가 지나온 갈림길을 순서대로 정리를 하고 있어야함!!
: 가장 마지막에 만났던 갈림길 부터 역순으로 끄집어 내기 위한 자료구조가 필요한데, 2가지가 있다; 스택, 재귀.

-DFS, BFS의 차이점은? 이라는 질문이 들어온다면,
; 스택을 사용하고~ 사용하고 끝! ->이러면 안된다.
: 갈림길, 후입선출(스택사용)혹은 재귀구조로 구현. -> 이러면 win!!

[참고] -로봇이 선을 따라 모든 칸을 탐색하는 방법
: 앞으로 갔다가, 갈림길로. 없으면 후진.

-코드

```
visited[], stack[] 초기화
DFS(v)
    시작점 v 방문;
    visited[v] <- true;
    while{
        if (v의 인접 정점 중 방문 안 한 정점 w가 있으면)
            push(v);
            v <- W; (w에 방문)
            visited[w] <- true
}
```

### DFS의 예

1. 정점 A를 시작으로 깊이 우선 탐색

깊이 우선 탐색 경로: A-B-D-F-E-C-G

연습문제3
: 다음은 연결되어 있는 두개의 정점 사이의 간선을 순서대로 나열해 놓은 것이다. 모든 정점을 깊이 우선 탐색하여, 화면에 깊이 우선 탐색 경로를 출력하시오. 시작 정점을 1로 시작하시오.
1 2 1 3 2 4 2 5 4 6 5 6 6 7 3 7

- 출력 결과의 예는 다음과 같다.
  1 2 4 6 5 7 3

[DFS 입력방법]

```
# 1
# 7 8
# 1 2 1 3 2 4 2 5 4 6 5 6 6 7 3 7
# 1 과 1*2 +1
# 2와 2*1+1
# ...

#인접 리스트로 저장하는 방법
T = int(input())
for tc in range(1, T+1):
    V, E = map(int, input().split())
    adjL = [[] for _ in range(V+1)]
    arr = list(map(int, input().split()))
    for i in range(E):
        v1, v2 = arr[i*2], arr[i*2+1]
        adjL[v1].append(v2) # 원래는 adjL[[],[],[],...]이렇게 비어있엇는ㄴ데, append해주는 거임
        adjL[v2].append(v1)
    print(adjL)


출력:
[[], [2, 3], [1, 4, 5], [1, 7], [2, 6], [2, 6], [4, 5, 7], [6, 3]]
```

```
# 1
# 7 8
# 1 2 1 3 2 4 2 5 4 6 5 6 6 7 3 7
# 1 과 1*2 +1
# 2와 2*1+1
# ...

#인접 행렬로 저장하는 방법
def DFS(s, V):  #s시작정점, V 정점개수(1번부터인 정점의 마지막 정점)
    visited = [0]*(V+1) #방문한 정점을 표시
    stack = []  #스택은 크기를 미리 지정해 놓고 하는 것이 목표지만, 그냥 해놓고 점점 늘여?가라.
    print(s)## 방문한 시점에 출력을 해보자.
    visited[s] = 1  #시작정점 방문표시
    v = s
    while True:
        for w in adjL[v]:    # v에 인접하고, 방문안한 w가 있으면
            if visited[w] == 0:
                stack.append(v)#방문을 안햇으면, 현재정점을 push하고
                v = w           #w 에 방문
                print(v)## 방문한 시점에 출력을 해보자.
                visited[w] = 1     #w에 방문 표시
                break           # 하나도 방문안한곳이 잇으면 그리로가야하니, 갈림길을 꺼내는 것은 중지. w, v부터 다시 탐색
        else:                   # 남은 인접정점이 없어서 break가 걸리지 않은 경우
            if stack:   # 이전 갈림길을 스택에서 꺼내서 ... if TOP > -1( 스택에서 남은 게 있다면,)
                v = stack.pop()
            else:
                break   #shile True에 대한 브레이크


T = int(input())
for tc in range(1, T + 1):
    V, E = map(int, input().split())
    adjL = [[] for _ in range(V + 1)]
    arr = list(map(int, input().split()))
    for i in range(E):
        v1, v2 = arr[i * 2], arr[i * 2 + 1]
        adjL[v1].append(v2)  # 원래는 adjL[[],[],[],...]이렇게 비어있엇는ㄴ데, append해주는 거임
        adjL[v2].append(v1)
    DFS(1, V)
```

-dfs는 변형이 많다. 다양한 코드들이 존재한다.

# 강사님 설명

트리: 비선형구조
: 원소들 간에 1:N구조를 가짐
등등..

그래프: 비선형 구조
: 트리랑 같다. 데이터가 퍼져잇음.
:트리랑 차이: 서로 얽힐 수 있다.

->>: dfs, bfs를 왜 배워?
이렇게 퍼져잇는 구조를 탐색하기 위한 방법으로
dfs, bfs를 사용하여 놓치지 않고 탐색을 할 수 있다.
: 그래프의 표현방법: 간선리스트, 인접행렬, 인접리스트가 있다. -인접행렬: 0번 노드가 1, 2, 5, 6 이랑 연결되어잇음.
그래프를 이차원배열로 만들어주고, 붙어있는 친구들을 1로 표현을 해준다.

인접리스트를 공부하기 위해,
; 연결리스트?란?
리스트의 장점이자, 단점: 순차적이다. 중간에 수를 하나 추가하려면, 뒤로 쫙밀어야함. 그래서 속도가 느림. -연결리스트는 인덱스로 접근이 안됨.
{0:[1, 2, 5, 6], 1:[0], ...}
;; 0번 정점은 1,2, 5, 6이랑 연결되어있다.
[[문제풀때]]
;; a랑 b랑 연결되어있니? -> 이차원 배열형태 사용(인접행렬)사용하는 게 좋음.
;; 얘랑 연결된 거 싹다 가져와-> 인접리스트 사용.
