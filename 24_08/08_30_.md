## APS응용

- sw 문제해결
- 복잡도 분석**
- 표준 입출력 방법
- 진수
- 비트 연산
- 실수

중에서 비트연산과 실수를 알아보자

### 비트 연산

-비트와 바이트
: 1bit: 0과 1을 표현하는 정보의 단위
: 1Byte: 8 bit를 묶어 1Byte라고 한다.
: 알고리즘에서는 KB, MB까지만 생각해주면됨.
: 파이썬은 int, string은 ..?
: 파이썬 기준으로 28byte를 먹는다.
다른 언어보다 크고, 더늘어날수 있다.

(c언어는 int 4바이트, char 1바이트)

-예시
1001011011011100은 총 몇 비트이면서, 몇 바이트인가?
: 16bit, 2byte

print(1)
#1을 한번 밀어준다(그냥 왼쪽으로 한칸씩 밀어주는것)
# print(1<<1)
print(1<<1, bin(1<<1))

#1을 한번더 밀어준다(그냥 왼쪽으로 한칸씩 밀어주는것)
print(1<<2, bin(1<<2))

print(1<<3)

print(1<<4)

#7을 우측으로 두번밀면, 두개가 삭제되어 1만 남는다.
print(7>>2, bin(7>>2))


비트 연산 응용1
` 1<<n
: 2^n의 값을 갖는다.
: 임베디드 분야에서 계산을 빠르게 하기 위해 사용된다. 
:: 부분집합의 갯수

arr = [1, 2, 3, 4]

print(f'부분집합의 수 : {1 <<len(arr)}')

 왜 부분집합의 수를 구할 수 있는가?
 각 자리를 쓴다/안쓴다-> 나올 수 있는 경우의 수 = 2가지
 각 자리마다 2가지 경우의 수 -> N길이라면 -> 2^N만큼의 경우의 수가 나올 수 있다.
for i in range(1 << len(arr)):
    print(i, end= ' ')
print()


비트 연산 응용2 ????????????????????????????????
` i& (1<<n)
: i의 n번째 비트가 1인지 아닌지 확인할 수 있다. 
: ex) 1101&(1<<2)
1101에서 2번 bit가 1인지 확인 가능하다(결과값 100)
결과값이 1보다 크면 n번째 비트는 1임이 확정된다. 



i&(1 << N) : N번째 비트가 0인지 아닌지 알 수 있다.
i 의미: i 번째 부분집합
0번째 부분 집합은 어떤것이 들어가나요? 를 물어보는 코드이다.

for i in range(1<< len(arr)):
    for idx in range(len(arr)):
        # i & (i << idx)
        # - i 번째 부분집합에 idx 요소가 포함되어 있나요?
        if i & (1<<idx):# 인데스가 해당자리의 부분집합을 포함 시킬 건지 안시킬건지. 그런의미가 되어서
            # 이 코드를 이용하면 재귀없이 모든 부분집합을 구할 수 있다.
            print(arr[idx], end=' ')# 포함되어있다면, 출력하는 것.
    print()



#### 비트연산 _ 음수 표현 방법
: 부호를 표시하는 비트를 쓰자.

방법1.맨 앞을 부호비트로 사용?-> 단점: 한자리가 줄어듬. 불편.

방법2. 1의 보수
0100을
1011로 쓴다
: 문제점이 좀 있다.

방법3. 2의 보수: 가장 많이 쓰임: 반전, +1해주기

: 2의 보수 사용하는 이유: 덧셈기
:: 덧셈만드로 뺄셈이 가능.

: 뒤집고 더하기 1을 두번하면 원래되로 돌아온다. 

((+ 보수 취할때만 올려지는 비트는 버려진다.))

#### 비트연산_ NOT연산자(~)
- 모든 비트를 반전 시킨다.

print(bin(4))
print(bin(~4))
print(~4) #5

- 컴퓨터는 실수를 내부적으로 근사적으로 관리한다
: 실수는 정확한 값이 아니라, 근사값으로 저장되는데, 이때 생기는 작은 오차가 계산과정에서 다른 결과를 가져온다. 


```
t= 0.1
print(f'{t:.20f}')

```

 ""비트""로 표현하면 무한 반복되는 숫자끼리 더하기 때문에
 오차가 발생한다!
print(0.1+ 0.1 == 0.2) # True: 오차가 허용범위 안이다
print(0.1+0.1+0.1 == 0.3) # False: 오차가 허용범위 밖이다.

 우리가 실수를 쓸때마다, 허용범위 안인지 알아야 할까?
 아니! 코테는 다 반욜림하라~ 라고 나와있다.

- 실수의 표현
: 컴퓨터는 실수를 표현하기 위해 부동소수점 표기법을 사용한다.

이 표기법은 IEEE 754이라는 컴퓨터에서 부동소수점을 표기하는 국제 표준이다.

: 부동(=float) 소수점 표기 방법은 소수점의 위치를 밑과 지수를 뭐로 두느냐에 따라, 소수점의 위치를 변화시켜 표현하는 방식이다.

소수점의 위치를 왼쪽의 가장 유효한 숫자 다음으로 고정시키고 밑수의 지수승으로 표현

: 실수를 저장하기 위한 형식
-  32bit 구조
 : 부호 1비트
 : 지수부
 : 가수부

- 컴퓨터는 실수를 근사적으로 표현한다.
: 이진법으로 표현 할 수 없는 형태의 실수는 정확한 값이 아니라,
근사값으로 저장되는데, 이때 생기는 작은 오차가 계산과정에서 다른 결과를 가져온다.

- 실수 자료형의 유효 자릿수를 알아두자.
-  32 비트 실수형 유효자릿수(십진수)-> 약 6자리(C++)
-  64 비트 실수형 유효자릿수(십진수)-> 약 15자리(C++, java)