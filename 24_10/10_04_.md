# 웹 크롤링

## 웹스크래핑
## 웹크롤링
: 두개는 같은 기술이다. 
스크래핑이 한페이지라면, 크롤링은 여러 페이지를 자동화.
구분을 잘 안하고, 같이 혼용한다. 크롤링이라고 범용적으로 말하자. 

: 여러 웹페이지를 돌아다니며 원하는 정보를 모으는 기술
: 원하는 정보를 추출하는 스크래핑과 여러 웹 페이지를 자동으로 탐색하는 크롤링의 개념을 합쳐 웹 크롤링이라고 부름
: 즉, 웹 사이트들을 돌아다니며 필요한 데이터를 추출할 수 있도록 자동화 된 프로세스


- 웹 크롤링 프로세스 
  - 웹페이지 다운로드
    : 해당 웹페이지의 HTML, CSS, JavaScript(역할: 페이지 자체를 바꿔주는 역할, 즉 동적인 부분을 자바스크립트가 담당) 등의 코드를 가져오는 단계
  - 페이지 파싱(// 문자열 파싱: 문자열에서 우리가 원하는 부분만 가져오는 것.)
    : 다운로드 받은 코드를 분석하고 필요한 데이터를 추출하는 단계
  - 링크 추출 및 다른 페이지 탐색
    : 다른 링크를 추출하고, 다음 단계로 이동하여 원하는 데이터를 추출하는 단계
    (ex. 페이징, 페이지를 나누어놨다. 페이지네이션)
  - 데이터 추출 및 저장-> (여기서 pandas와 web crawing을 이용할 수 있다.)
    : 분석 및 시각화에 사용하기 위해 데이터를 처리하고 저장하는 단계

- 웹 크롤링 실습
  - 준비 단계
    : requests: HTTP 요청을 보내고 응답을 받을 수 있는 모듈
    request.get(URL)
    ->> GET method
    -> 조회, 즉 GET 요청을 보내는 거다.
    : BeautifulSoup : HTML문서에서 원하는 데이터를 추출하는데 사용되는 파이썬 라이브러리
    ->> 페이지 하나가 그냥 request로 가져오면, 복잡한 문자열로 가져왔었다.
    : Selenium : 웹 애플리케이션


- request모듈은 정적인 부분, 즉 서버가 이미 가지고 있는 데이터만 다운로드 가능.
  => 동적인 컨텐츠를 다운로드 받을 수 없다! (탕수육이라는 결과를 통해서 변경되는 부분이 동적인 부분이다.)

  => 그럼 동적인 컨텐츠를 받을 수 있는 방법은? selenium
  selenium: 개발자들이 동적 웹 테스트를 위해서 많이 사용-> 오늘 크롤링에서 활용.

[참고]BeautifulSoup4 요소 선택 메서드 종류
  - find()
  - find_all()
  - select()
  - select_one()
  - 
  - 

## Django에서 활용하기


```
실습

    #1. 크롤링ㅣ:: 검색을 할 수 잇도록 http://127.0.0.1:8000/crawlings/화면을 구성
    #2. DB에 저장-> 중복 제거
    #3. 제목출력

```

1. models.py
```
class Article(models.Model):
    query = models.TextField()
    title = models.TextField()
```
+ 추가 설명 : 테이블 쪼개기
```

# +
class Article(models.Model):
    title = models.TextField()

# 하나의 쿼리로 여러개의 게시글을 검색 할 수 잇음
class Article(models.Model):
    name = models.TextField()
```


```
rm db.sqlite3

python manage.py makemigrations

```

crawling> views.py에서 
사용자가 검색을 하면 크롤링을 진행하는 부분을 만들어 주기.
```
1. 검색하는 입력을 받는 부분을 
index.html에서 만들어 주기


<form action="{% url "crawlings:index" %}" method = "POST">
  {% csrf_token %}
  <label for="query">검색어</label>
  <input type="text" id="query" name="query" >
  <button>검색하기</button>
  {% comment %} <input type="submit" value = "검색하기"> {% endcomment %}
  {% comment %} -> 버튼을 써도, input을 써도 상관없는데,
  button이 간단하고, form태그안에 잇으면 자동으로  submit을 해준다. {% endcomment %}
</form>

```

```
2. views.py에서 크롤링하기
def index(request):
    # 사용자가 검색을 하면, 크롤링을 진행
    if request.method == 'POSt':
        results = [] #검색 결과를 모으기
        # 아까 index.html에서 query라는 이름으로 인풋을 담아줬으니
        query = request.POST.get('query')
        # 크롤링 로직을 쿠리를  통해 하는거를 , example3번에 이미 만들어 놓은것을 가져오자. 
        #(함수만 다 들고 오자)
        titles = 


- 가져온 example3.py 약간 수정하기
titles = []
    # 해당 요소를 반복하며
    for g in g_list:
        # 요소 안에 LC20lb MBeuO DKV0Md 클래스를 가진 특정 요소 선택
        title = g.select_one(".LC20lb.MBeuO.DKV0Md")
        # 요소가 존재 한다면
        if title is not None:
            title_text = title.text
            # print('제목 = ', title_text)
            titles.append(title_text)
    return titles


```

```
def index(request):
    # 사용자가 검색을 하면, 크롤링을 진행
    if request.method == 'POST':
        results = [] #검색 결과를 모으기
        # 아까 index.html에서 query라는 이름으로 인풋을 담아줬으니
        query = request.POST.get('query')
        # 크롤링 로직을 쿠리를  통해 하는거를 , example3번에 이미 만들어 놓은것을 가져오자. 
        #(함수만 다 들고 오자)
        titles = get_google_data(query)
        # print(titles)

        for title in titles:
            # #Article을 저장하는 것(단, 중복을 제거)
            # Article.objects.create(query= query, title = title)

            # # (실행할 때 마다 같은 데이터 를 저장할 수는 업으니까,)중복을 제거하자
            # if not Article.objects.filter(query=query, title= title).exists():
            #     Article.objects.create(query= query, title = title)

            # 있으면 가져오고, 없으면 저장해라-> 이걸 하는 메서드는?
            article, created_article = Article.objects.get_or_create(query=query, title= title)


    # 위에꺼를 그대로 출력하기 위해서, 밑에서 가져와서(~.all) 저장해라. 
    context = {
        'results': Article.objects.all()
    }
    #-> index.html가서 출력하기

    # 아니라면, 그냥 검색 페이지를 제공
    return render(request, 'crawlings/index.html')
```

 #-> index.html가서 출력하기
```

{% for result in results %}
  <p>{{forloop.counter }}{{result.title}}</p>
{% endfor %}
```

[한걸음더]

인증된 유저만 크롤링 가능
index.html에서



-----------------------


```

# 목차
## 기초지식
## Branch

## 기초지식
```bash
# 이 폴더를  git오로 관리 하겠다.
$ git init
```

- 현재 작업중인 폴더 내의 .git을 제외한 폴더 위치를  'working directory'

- 'working directory' 에만 작성한 내용은 아직 git이 어떤 변동사항이 있는지 모른다.


```bash
# staging area에 해당하는 다일을 등록
$ git add { file_path }

```

- 'staging area' 란, 등록한 파일들의 변동사항만 기록한 txt 파일을 '.git'폴더 어딘가에 모아둔다,

```bash
# staging area에 등록해둔 변동사항을 하나의 버전으로 등록한다.
# 그후 staging area는 비운다.
$ git commit -m "commit message"
```


- 'commit' 즉, 버전이란 아까전 'staging area' 에 등록해준 변동사항만을 모아서 하나의 상태로 저장한다.,
- 그곳을 'repository'라고 부른다

--  여기까지 내 컴퓨터---

ex) 신발의 일부를 만들어 서 단상에 올리는게 add,
사진을 찍어올리고,,
레포짓에 버전1(밑창), 버전2(윗동), 버전3(신발끈)을 저장.
-> 버전 1, 2, 3 을 합치면 하나의 신발완성


repository = remote repository(원격레포짓)


git push origin master
: origin:저장소의 이름
: master: 이게 브런치 이름이다.!! 오늘은 여기 !!


------------------

## Branch

### git branch
: 나뭇가지 처럼 여러 갈래로 작업 공간을 나누어
독립적으로 작업할 수 있도록 도와주는 Git의 도구.

: 장점:
  1. 독립된 개발 환경을 형성하기 때문에 원본(master)에 대해 안전
  2. 하나의 작업은 하나의 브랜치로 나누어 진행되므로, 체계적으로 협업과 개발이 가능
  3. 손쉽게 브랜치를 생성하고 브랜치 사이를 이동할 수 있음.

### branch를 꼭 사용해야 할까?
  - 만약 상용중인 서비스에 발생한 에러를 해결하려면?
    1. 브런치를 통해 별도의 작업 공간을 만든다.
    2. 브랜치에서 에러가 발생한 버전을 이전 버전으로 되돌리거나 삭제한다.
    3. 브랜치는 완전하게 독립 되어있어서 작업 내용을 master브랜치에 아무런 영향을 끼치지 못한다.
    4. 이후 에러가 발생했다면?
    ...?


### branch를 만들어보자!

- checkout 말고..
branch 랑 switch를 이용해보자!

git branch : 브랜치 목록 확인
git branch -r : 원격 저장소의 브랜치 목록 확인
git branch <브랜치 이름> : 새로운 브랜치 생성
git branch -d <브랜치 이름> : 브랜치 삭제(병합된 프랜치만 삭제 가능)
git branch -D <브랜치 이름> : 브랜치 삭제(강제 삭제)

  -> 우린 D는 안쓴다. 없는 명령어로 치자.


----------------
필기 내용
# branch

git switch som
하고나서 
git log를 찍어보면,
HEAD-> 가 어디를가르키고 잇는지를 통해 알 수 있다.





[실습]


git init
touch README.md
git add .
git commit -m "first commit"
git log
git branch
git branch som
git branch
git switch som
git log
__ 여기서 README파일 수정하고~
git add README.md
git commit -m "som 2 작업함"
git log --oneline
git switch master



[2교시]
touch master.md
git status
git add master.md
git commit -m "master.md 추가"
git log
git log --oneline
git switch som
git log --oneline
git switch master
git merge som
git log --oneline
git branch -d som
git branch
git branch somsom
git log --oneline
touch test.md
git add test.md
git commit -m "새로만듬"
git log --oneline
git switch master
git merge somsom
git log --oneline
git log --oneline --graph

git branch -d somsom 
git branch
git branch min
git branch
git switch min 
git add .
git commit -m "min doing"
git switch master
git merge min
git add .
git commit -m "notice"
git merge min
git add .
git commit -m"conflict complete"
git log --oneline

원격을 추가하기 
git remote add origin 깃허브 복사한 주소
git push origin master
git branch






















->>
 git add README.md
하기전에 README.md에서 변경사항을 만들자.


---
2교시

폴더가 working area이다.

merge
:q
```